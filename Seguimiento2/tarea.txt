1. Revisi√≥n y preparaci√≥n de los datos
Objetivo: Reunir y preparar los abstracts cient√≠ficos y las categor√≠as del proyecto.

1.1. Recolectar los archivos .bib que contienen los abstracts.
1.2. Extraer los abstracts desde los archivos .bib.
1.3. Organizar los abstracts en una estructura legible (por ejemplo, una lista o dataframe).
1.4. Asociar cada abstract con sus keywords si est√°n disponibles.
1.5. Clasificar las keywords en una o varias de las categor√≠as provistas.

üîπ 2. Preprocesamiento del texto
Objetivo: Convertir los abstracts en representaciones num√©ricas √∫tiles para clustering.

2.1. Limpiar los textos: eliminar puntuaci√≥n, convertir a min√∫sculas, eliminar stopwords, etc.
2.2. Tokenizar y aplicar stemming o lematizaci√≥n.
2.3. Representar los textos mediante una t√©cnica vectorial como:

TF-IDF

Bag-of-Words

Word Embeddings (opcional, si quieres mayor complejidad)

üîπ 3. C√°lculo de similitud entre abstracts
Objetivo: Medir cu√°n similares son los abstracts entre s√≠.

3.1. Elegir una m√©trica de similitud (coseno, euclidiana, etc.).
3.2. Calcular la matriz de similitud/distancia entre los abstracts usando la representaci√≥n vectorial.

üîπ 4. Implementaci√≥n de dos algoritmos de clustering jer√°rquico
Objetivo: Aplicar agrupamiento jer√°rquico para construir dendrogramas.

4.1. Elegir dos algoritmos diferentes de clustering jer√°rquico, por ejemplo:

Enlace completo (complete linkage)

Enlace promedio (average linkage)
4.2. Implementar cada algoritmo utilizando estructuras de datos distintas, por ejemplo:

Uno con listas enlazadas / matrices

Otro con √°rboles / objetos personalizados
4.3. Aplicar los algoritmos a la matriz de similitud/distancia.

üîπ 5. Visualizaci√≥n con dendrogramas
Objetivo: Representar los agrupamientos jer√°rquicos.

5.1. Usar una biblioteca (como scipy.cluster.hierarchy o matplotlib) para construir y visualizar los dendrogramas.
5.2. A√±adir etiquetas a los nodos o ramas si es posible (ej. t√≠tulo del abstract o su categor√≠a principal).

üîπ 6. Evaluaci√≥n de la coherencia de los agrupamientos
Objetivo: Determinar qu√© algoritmo produce mejores resultados seg√∫n las categor√≠as.

6.1. Definir una m√©trica de evaluaci√≥n (por ejemplo, purity, homogeneidad, ARI).
6.2. Comparar las agrupaciones con las categor√≠as derivadas de las keywords.
6.3. Determinar cu√°l de los dos algoritmos produce agrupamientos m√°s coherentes.

Adjunto las categor√≠as con sus variables:
Categor√≠a
Habilidades 
Abstraction
Algorithm
Algorithmic thinking
Coding
Collaboration
Cooperation
Creativity
Critical thinking
Debug
Decomposition
Evaluation
Generalization
Logic
Logical thinking
Modularity
Patterns recognition
Problem solving
Programming

Conceptos
Computationales

Conditionals
Control structures
Directions
Events
Funtions
Loops
Modular structure
Parallelism
Sequences
Software/hardware
Variables
Actitudes Emotional
Engagement
Motivation
Perceptions
Persistence
Self-efficacy
Self-perceived

Propiedades
psicom√©tricas

Classical Test Theory - CTT
Confirmatory Factor Analysis - CFA
Exploratory Factor Analysis - EFA
Item Response Theory (IRT) - IRT
Reliability
Structural Equation Model - SEM
Validity

Herramienta de
evaluaci√≥n

Beginners Computational Thinking test - BCTt
Coding Attitudes Survey - ESCAS
Collaborative Computing Observation Instrument
Competent Computational Thinking test - cCTt
Computational thinking skills test - CTST
Computational concepts
Computational Thinking Assessment for Chinese Elementary
Students - CTA-CES
Computational Thinking Challenge - CTC
Computational Thinking Levels Scale - CTLS
Computational Thinking Scale - CTS
Computational Thinking Skill Levels Scale - CTS
Computational Thinking Test - CTt
Computational Thinking Test
Computational Thinking Test for Elementary School Students
Computational Thinking Test for Lower Primary - CTtLP
Computational thinking-skill tasks on numbers and arithmetic
Computerized Adaptive Programming Concepts Test - CAPCT
CT Scale - CTS
Elementary Student Coding Attitudes Survey - ESCAS
General self-efficacy scale
ICT competency test
Instrument of computational identity

KBIT fluid intelligence subtest
Mastery of computational concepts Test and an Algorithmic Test
Multidimensional 21st Century Skills Scale
Self-efficacy scale
STEM learning attitude scale
The computational thinking scale

Dise√±o de
investigaci√≥n

No experimental
Experimental
Longitudinal research
Mixed methods
Post-test
Pre-test
Quasi-experiments

Nivel de
escolaridad

Upper elementary education - Upper elementary school
Primary school - Primary education - Elementary school
Early childhood education ‚Äì Kindergarten -Preschool
Secondary school - Secondary education
high school - higher education
University ‚Äì College
Medio Block programming
Mobile application
Pair programming
Plugged activities
Programming
Robotics
Spreadsheet
STEM
Unplugged activities

Estrategia 

Construct-by-self mind mapping
Construct-on-scaffold mind mapping
Design-based learning
Evidence-centred design approach
Gamification
Reverse engineering pedagogy
Technology-enhanced learning
Collaborative learning
Cooperative learning
Flipped classroom
Game-based learning
Inquiry-based learning
Personalized learning
Problem-based learning
Project-based learning
Universal design for learning

Herramienta 

Alice
Arduino
Scratch
ScratchJr
Blockly Games
Code.org
Codecombat
CSUnplugged
Robot Turtles
Hello Ruby
Kodable
LightbotJr
KIBO robots
BEE BOT
CUBETTO
Minecraft
Agent Sheets
Mimo
Py‚Äì Learn
SpaceChem

